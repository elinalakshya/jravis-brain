# jravis_daily_report.py
# JRAVIS daily report with PDF generation + password encryption + direct-SMTP send
import os
from datetime import datetime
from dotenv import load_dotenv
from pathlib import Path
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from PyPDF2 import PdfReader, PdfWriter
from email.message import EmailMessage
import tempfile
from smtp_direct_sender import send_direct

load_dotenv()

# Config
SENDER = os.getenv("JRAVIS_SENDER", "reports@jravis.local")
RECEIVERS = os.getenv("JRAVIS_RECEIVERS", "nrveeresh327@gmail.com").split(",")
LOCK_CODE = os.getenv("JRAVIS_LOCK_CODE", "0000")  # Default lock code

OUTPUT_DIR = Path.home() / "workspace" / "jravis" / "reports"
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

def build_report_text() -> str:
    now = datetime.now()
    # Minimal summary â€” expand as needed
    lines = [
        f"JRAVIS Daily Report",
        f"Date: {now:%Y-%m-%d %H:%M:%S}",
        "",
        "Mission 2040 status: active",
        "Daily earnings: â‚¹0 (simulated)",
        "Tasks completed yesterday: None (simulated)",
        "Tasks scheduled today: None (simulated)",
        "",
        "Notes:",
        " - This report is auto-generated by JRAVIS.",
        " - PDF is encrypted with the lock code."
    ]
    return "\n".join(lines)

def create_pdf(path: Path, text: str):
    """Create a simple one-page PDF (A4) with the provided text."""
    c = canvas.Canvas(str(path), pagesize=A4)
    width, height = A4
    margin = 40
    y = height - margin
    x = margin
    line_height = 14
    c.setFont("Helvetica", 11)

    for line in text.splitlines():
        c.drawString(x, y, line)
        y -= line_height
        if y < margin:
            c.showPage()
            y = height - margin
            c.setFont("Helvetica", 11)
    c.save()

def encrypt_pdf(input_path: Path, output_path: Path, password: str):
    """Encrypt input PDF into output PDF using PyPDF2 (owner+user password same)."""
    reader = PdfReader(str(input_path))
    writer = PdfWriter()
    for page in reader.pages:
        writer.add_page(page)
    # encrypt with both user and owner the same code (works for opening)
    writer.encrypt(user_pwd=password, owner_pwd=password, use_128bit=True)
    with open(output_path, "wb") as fh:
        writer.write(fh)

def build_email_with_attachment(sender: str, receiver: str, subject: str, body: str, attachment_bytes: bytes, attachment_name: str) -> EmailMessage:
    msg = EmailMessage()
    msg["From"] = sender
    msg["To"] = receiver
    msg["Subject"] = subject
    msg.set_content(body)
    # Attach encrypted PDF bytes
    msg.add_attachment(attachment_bytes, maintype="application", subtype="pdf", filename=attachment_name)
    return msg

def send_report():
    # Build text report
    report_text = build_report_text()
    now = datetime.now().strftime("%Y%m%d_%H%M%S")
    tmp_plain = OUTPUT_DIR / f"jravis_report_{now}.pdf"
    tmp_encrypted = OUTPUT_DIR / f"jravis_report_{now}_locked.pdf"

    create_pdf(tmp_plain, report_text)
    encrypt_pdf(tmp_plain, tmp_encrypted, LOCK_CODE)

    # read encrypted bytes
    with open(tmp_encrypted, "rb") as fh:
        pdf_bytes = fh.read()

    subject = f"JRAVIS Daily Report â€“ {datetime.now():%d-%m-%Y}"
    body = ("Hello Boss ðŸ‘‹\n\n"
            "âœ… JRAVIS Daily Report executed successfully.\n\n"
            f"Date: {datetime.now():%Y-%m-%d %H:%M:%S}\n\n"
            "The daily summary PDF is attached and encrypted with your lock code.\n\n"
            "Regards,\nDhruvayu âš™ï¸")

    # For each receiver build and send a message via existing send_direct (which
    # expects EmailMessage and will do MX lookup). We will re-use send_direct by
    # constructing an EmailMessage for each recipient and using the underlying
    # helper (send_direct in your current code accepts EmailMessage via send_direct()).
    # However send_direct() in smtp_direct_sender currently expects sender, [receivers], subject, body.
    # To reuse existing function, we'll convert to inline direct send by calling send_direct with body and letting it build EmailMessage.
    # Simpler: use send_direct wrapper that accepts EmailMessage bytes â€” but to avoid changing smtp_direct_sender,
    # we will create a tiny fallback: if smtp_direct_sender.send_direct accepts EmailMessage, it will work; else we will fallback to sending raw via smtp library.

    # TRY to use send_direct with EmailMessage support. If it fails, fall back.
    results = {}
    try:
        # Attempt: if send_direct supports an EmailMessage input path by checking callable signature, we'll call it.
        # The original send_direct accepts sender, receivers, subject, body, headers; we'll use that but it won't include attachment.
        # So to ensure attachments go through, build a raw message and call the internal low-level send via the MX hosts:
        from smtp_direct_sender import get_mx_hosts, send_via_host
        # Build a single EmailMessage and send bytes to MX hosts directly
        for rcpt in RECEIVERS:
            msg = EmailMessage()
            msg["From"] = SENDER
            msg["To"] = rcpt
            msg["Subject"] = subject
            msg.set_content(body)
            msg.add_attachment(pdf_bytes, maintype="application", subtype="pdf", filename=tmp_encrypted.name)

            # mx lookup & host send loop (reuse send_via_host)
            domain = rcpt.split("@",1)[1]
            mx_hosts = get_mx_hosts(domain)
            sent = False
            info_msgs = []
            for prio, host in mx_hosts:
                ok, info = send_via_host(host, SENDER, rcpt, msg, use_tls=True)
                info_msgs.append(info)
                if ok:
                    results[rcpt] = {"ok": True, "info": info}
                    sent = True
                    break
            if not sent:
                results[rcpt] = {"ok": False, "info": " ; ".join(info_msgs)}
    except Exception as e:
        # If anything goes wrong with the direct helper usage, fallback to simple text send (no attachment)
        fallback_results = send_direct(SENDER, RECEIVERS, subject, body, headers={"X-JRAVIS": "no-attachment-fallback"})
        # include a note about fallback
        for k,v in fallback_results.items():
            fallback_results[k]["note"] = f"attachment failed: {e}"
        results = fallback_results

    return results

if __name__ == "__main__":
    print(f"[JRAVIS Daily Report] Started at {datetime.now()}")
    res = send_report()
    for rcpt, info in res.items():
        print(f"-> {rcpt}: ok={info.get('ok')} info={info.get('info')}")
